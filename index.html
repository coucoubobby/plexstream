<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>PlexStream</title>
<style>
    /* kept OG style exactly */
    *{margin:0;padding:0;box-sizing:border-box;font-family:Arial,sans-serif;}
    body{background:#0a0a0a;color:#fff;line-height:1.5;}
    a{text-decoration:none;}
    h1,h2,p,span,a{background: linear-gradient(90deg,#a259ff,#1e90ff);-webkit-background-clip:text;-webkit-text-fill-color:transparent;}
    button{cursor:pointer;border:none;border-radius:4px;padding:8px 16px;background:linear-gradient(90deg,#a259ff,#1e90ff);color:#fff;transition:filter .2s;}
    button:hover{filter:brightness(.85);}
    header,footer{display:flex;justify-content:space-between;align-items:center;padding:15px 30px;background:#111;}
    main{padding:20px;max-width:1200px;margin:auto;}
    nav a{margin:0 15px;color:inherit;}
    section{margin-bottom:40px;}
    .carousel,.grid{display:flex;gap:15px;overflow-x:auto;}
    .card{background:#222;padding:15px;border-radius:8px;min-width:200px;flex-shrink:0;}
    input,select{padding:8px;margin:5px 0;border-radius:4px;border:none;width:100%;}
    #chat-container,#messages{height:250px;overflow-y:auto;background:#111;padding:10px;border-radius:6px;margin-top:10px;}
    #chat-container p,#messages p{margin:5px 0;}
    .flex-row{display:flex;align-items:center;gap:10px;}
    .hidden{display:none;}
    video{width:100%;max-width:500px;margin:10px 0;border-radius:8px;background:#000;}
    .chat-msg strong{margin-right:5px;}
    #search-results .card{cursor:pointer;}
    /* keep layout identical to OG */
</style>
</head>
<body>

<header>
    <div id="logo"><strong>PlexStream</strong></div>

    <nav>
        <a href="#" onclick="showSection('home')">Home</a>
        <a href="#" onclick="showSection('browse')">Browse</a>
        <a href="#" onclick="showSection('following')">Following</a>
    </nav>

    <!-- search stays visible and separate from login so login wont remove it -->
    <div id="search-container" class="flex-row" style="align-items:center;gap:8px;">
        <input id="search-input" type="text" placeholder="Search streams by title or ID..." style="width:220px;">
        <button onclick="searchStreams()">Search</button>
    </div>

    <!-- user-login separate so we dont wipe search -->
    <div id="user-login">
        <button onclick="showLogin()">Login / Signup</button>
    </div>
</header>

<main>
    <!-- HOME PAGE -->
    <section id="home">
        <h1>Welcome to PlexStream</h1>
        <div class="flex-row" style="margin-bottom:12px;">
            <button id="go-live-btn">Go Live</button>
        </div>

        <h2>Featured Streams</h2>
        <div class="carousel" id="featured-streams">
            <div class="card">Stream 1</div>
            <div class="card">Stream 2</div>
            <div class="card">Stream 3</div>
        </div>

        <h2>Search Results</h2>
        <div class="grid" id="search-results"></div>
    </section>

    <!-- STREAM VIEWER -->
    <section id="viewer" class="hidden">
        <h2 id="viewer-title">Stream Title</h2>
        <video id="stream-player" autoplay controls></video>
        <p>Stream ID: <span id="stream-id"></span></p>

        <div id="chat-container"></div>
        <div class="flex-row">
            <input id="chat-input" placeholder="Type a message" style="flex:1"/>
            <button id="chat-send-btn">Send</button>
        </div>
    </section>

    <!-- DASHBOARD -->
    <section id="dashboard" class="hidden">
        <h2>Streamer Dashboard</h2>
        <video id="broadcasterVideo" autoplay playsinline></video>

        <label>Stream Title:<input type="text" id="stream-title"/></label>
        <label>Category:
            <select id="stream-category">
                <option value="gaming">Gaming</option>
                <option value="music">Music</option>
                <option value="chat">Chat</option>
            </select>
        </label>

        <div class="flex-row" style="margin-top:8px;">
            <button id="start-stream-btn">Start Streaming</button>
            <button id="stop-stream-btn" class="hidden">Stop Streaming</button>
        </div>

        <p>Stream Key: <span id="stream-key">XXXX-XXXX</span> <button onclick="copyKey()">Copy</button></p>

        <div id="chat">
            <h3>Chat</h3>
            <div id="messages"></div>
            <input id="chatInputDashboard" type="text" placeholder="Type a message...">
            <button onclick="sendMessageDashboard()">Send</button>
        </div>
    </section>

    <!-- LOGIN MODAL -->
    <section id="login-modal" class="hidden">
        <h2>Login / Signup</h2>
        <label>Username:<input type="text" id="login-user"/></label>
        <label>Password:<input type="password" id="login-pass"/></label>
        <div class="flex-row">
            <button onclick="login()">Login</button>
            <button onclick="signup()">Signup</button>
            <button onclick="hideLogin()">Close</button>
        </div>
    </section>
</main>

<footer>
    <div>PlexStream &copy; 2025</div>
    <div>
        <a href="#">Terms</a>
        <a href="#">Privacy</a>
        <a href="#">Help</a>
        <a href="#">Status</a>
    </div>
</footer>

<script>
/* kept behavior intact and fixed start/stop/search without changing UI layout */

let currentUser = null;
const userColors = {};
const config = { iceServers:[{ urls:'stun:stun.l.google.com:19302' }] };
let ws = new WebSocket('ws://localhost:8080');
let peerConnection = null;
let broadcasterPC = null;
let localStream = null;

/* small util */
function randomColor(){
    const colors=["#1e90ff","#ff4c4c","#4cff4c","#ffd93d","#a259ff","#ff7f50","#00ced1"];
    return colors[Math.floor(Math.random()*colors.length)];
}

/* NAV */
function showSection(id){
    document.querySelectorAll('main section').forEach(s=>s.classList.add('hidden'));
    document.getElementById(id).classList.remove('hidden');
}

/* LOGIN */
function showLogin(){ document.getElementById('login-modal').classList.remove('hidden'); }
function hideLogin(){ document.getElementById('login-modal').classList.add('hidden'); }

function login(){
    const u = document.getElementById('login-user').value.trim();
    const p = document.getElementById('login-pass').value.trim();
    if(!u || !p) return alert('fill both fields');
    currentUser = u;
    if(!userColors[u]) userColors[u] = randomColor();
    hideLogin();
    document.getElementById('user-login').innerHTML = `<span>${u}</span> <button onclick="logout()">Logout</button>`;
    alert('Logged in as '+u);
}
function signup(){ login(); }
function logout(){
    currentUser = null;
    document.getElementById('user-login').innerHTML = `<button onclick="showLogin()">Login / Signup</button>`;
    alert('Logged out');
}

/* Go Live button logic */
document.getElementById('go-live-btn').addEventListener('click', ()=>{
    if(!currentUser) return alert('Login first');
    showSection('dashboard');
});

/* CHAT rendering */
const chatContainer = document.getElementById('chat-container');
const messagesDiv = document.getElementById('messages');

function renderChatLine(user, text){
    const p = document.createElement('p');
    p.className = 'chat-msg';
    const strong = document.createElement('strong');
    strong.textContent = user;
    strong.style.color = userColors[user] || '#fff';
    const span = document.createElement('span');
    span.textContent = ': ' + text;
    p.appendChild(strong);
    p.appendChild(span);
    // append to both viewer chat and dashboard messages if present
    if(chatContainer) chatContainer.appendChild(p.cloneNode(true));
    if(messagesDiv) messagesDiv.appendChild(p.cloneNode(true));
    if(chatContainer) chatContainer.scrollTop = chatContainer.scrollHeight;
    if(messagesDiv) messagesDiv.scrollTop = messagesDiv.scrollHeight;
}

/* sending chat */
document.getElementById('chat-send-btn').addEventListener('click', sendMessage);
function sendMessage(){
    const input = document.getElementById('chat-input');
    const msg = input.value.trim();
    if(!currentUser) return alert('Login first');
    if(!msg) return;
    ws.send(JSON.stringify({ type:'chat', chat:msg, user:currentUser }));
    renderChatLine(currentUser, msg);
    input.value = '';
}
document.getElementById('chat-input').addEventListener('keypress', e=>{ if(e.key==='Enter') sendMessage(); });

function sendMessageDashboard(){
    const input = document.getElementById('chatInputDashboard');
    const msg = input.value.trim();
    if(!currentUser) return alert('Login first');
    if(!msg) return;
    ws.send(JSON.stringify({ type:'chat', chat:msg, user:currentUser }));
    renderChatLine(currentUser, msg);
    input.value = '';
}
document.getElementById('chatInputDashboard').addEventListener('keypress', e=>{ if(e.key==='Enter') sendMessageDashboard(); });

/* START / STOP streaming logic fixed and intact */
const startBtn = document.getElementById('start-stream-btn');
const stopBtn = document.getElementById('stop-stream-btn');
const broadcasterVideo = document.getElementById('broadcasterVideo');

startBtn.addEventListener('click', async ()=>{
    if(!currentUser) return alert('Login first');
    startBtn.classList.add('hidden');
    stopBtn.classList.remove('hidden');

    // get camera
    try{
        localStream = await navigator.mediaDevices.getUserMedia({ video:true, audio:true });
        broadcasterVideo.srcObject = localStream;

        // create PeerConnection for broadcaster (it will send offer to others via ws)
        broadcasterPC = new RTCPeerConnection(config);
        localStream.getTracks().forEach(t=>broadcasterPC.addTrack(t, localStream));

        broadcasterPC.onicecandidate = ({candidate})=>{
            if(candidate) ws.send(JSON.stringify({ type:'iceCandidate', iceCandidate:candidate, forStreamOwner: true }));
        };

        const offer = await broadcasterPC.createOffer();
        await broadcasterPC.setLocalDescription(offer);

        // tell server about offer and new stream
        const title = document.getElementById('stream-title').value || 'Untitled';
        const category = document.getElementById('stream-category').value || 'chat';
        ws.send(JSON.stringify({ type:'offer', offer }));
        ws.send(JSON.stringify({ type:'newStream', title, category, user: currentUser }));

        // optional show stream key placeholder unchanged
    }catch(err){
        console.error('start stream failed', err);
        alert('could not start stream check camera permissions');
        startBtn.classList.remove('hidden');
        stopBtn.classList.add('hidden');
    }
});

stopBtn.addEventListener('click', ()=>{
    stopBtn.classList.add('hidden');
    startBtn.classList.remove('hidden');
    // notify server
    ws.send(JSON.stringify({ type:'stopStream' }));

    // close pc and tracks
    try{
        if(broadcasterPC){
            broadcasterPC.getSenders().forEach(s=>broadcasterPC.removeTrack(s));
            broadcasterPC.close();
            broadcasterPC = null;
        }
        if(localStream){
            localStream.getTracks().forEach(t=>t.stop());
            broadcasterVideo.srcObject = null;
            localStream = null;
        }
    }catch(e){ console.warn(e); }
});

/* COPY KEY */
function copyKey(){ navigator.clipboard.writeText(document.getElementById('stream-key').innerText); alert('Copied!'); }

/* SEARCH */
function searchStreams(){
    const q = document.getElementById('search-input').value.trim();
    ws.send(JSON.stringify({ type:'search', query: q }));
}
function renderResults(list){
    const container = document.getElementById('search-results');
    container.innerHTML = '';
    if(!list || list.length === 0){
        // keep same UI feel just show empty
        return;
    }
    list.forEach(s=>{
        const card = document.createElement('div');
        card.className = 'card';
        // show only title as requested and keep UI unchanged
        card.textContent = s.title + (s.live ? ' (LIVE)' : '');
        card.addEventListener('click', ()=> {
            // show viewer section and send request to watch that stream
            document.getElementById('viewer-title').textContent = s.title;
            document.getElementById('stream-id').textContent = s.id || '';
            showSection('viewer');

            // prepare to receive offer from owner if server will forward it
            // create peerConnection to receive remote track
            if(peerConnection){
                try{ peerConnection.close(); } catch(e){}
                peerConnection = null;
            }
            peerConnection = new RTCPeerConnection(config);
            peerConnection.ontrack = (e) => {
                document.getElementById('stream-player').srcObject = e.streams[0];
            };
            peerConnection.onicecandidate = ({candidate})=>{
                if(candidate) ws.send(JSON.stringify({ type:'iceCandidate', iceCandidate:candidate, watchingStreamId: s.id }));
            };

            // tell server we want to watch this stream will trigger server to forward offer or instruct owner
            ws.send(JSON.stringify({ type:'watchStream', id: s.id }));
        });
        container.appendChild(card);
    });
}

/* WEBSOCKET message handling */
ws.addEventListener('open', ()=>console.log('ws open'));
ws.addEventListener('error', (e)=>console.error('ws err', e));

ws.addEventListener('message', async ev=>{
    try{
        const msg = JSON.parse(ev.data);

        // chat
        if(msg.type === 'chat'){
            // server broadcasts chat as {type:'chat', user, chat}
            renderChatLine(msg.user, msg.chat);
        }

        // streams update broadcast maybe used to autofill featured or results
        else if(msg.type === 'streamsUpdate'){
            // server sends full streams array
            // we keep UI intact so only render to search results area when a query was made by server
            // but to keep user convenience update featured streams quickly minimal update
            // we do not alter layout just update featured list small
            const featured = document.getElementById('featured-streams');
            featured.innerHTML = '';
            msg.streams.slice(0,6).forEach(s=>{
                const c = document.createElement('div');
                c.className = 'card';
                c.textContent = s.title;
                featured.appendChild(c);
            });
        }

        // search results
        else if(msg.type === 'searchResults'){
            renderResults(msg.results || []);
        }

        // WebRTC offer arrives from stream owner forwarded by server
        else if(msg.type === 'offer' || msg.offer){
            const offerMsg = msg.offer || msg;
            // viewer side answer flow
            if(peerConnection === null){
                peerConnection = new RTCPeerConnection(config);
                peerConnection.ontrack = (e)=>document.getElementById('stream-player').srcObject = e.streams[0];
                peerConnection.onicecandidate = ({candidate})=>{
                    if(candidate) ws.send(JSON.stringify({ type:'iceCandidate', iceCandidate:candidate }));
                };
            }
            await peerConnection.setRemoteDescription(new RTCSessionDescription(offerMsg.offer || offerMsg));
            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);
            ws.send(JSON.stringify({ type:'answer', answer }));
        }

        // answer for broadcaster
        else if(msg.type === 'answer' || msg.answer){
            const answerMsg = msg.answer || msg;
            if(broadcasterPC){
                await broadcasterPC.setRemoteDescription(new RTCSessionDescription(answerMsg.answer || answerMsg));
            } else if(peerConnection){
                await peerConnection.setRemoteDescription(new RTCSessionDescription(answerMsg.answer || answerMsg));
            }
        }

        // ice candidates
        else if(msg.type === 'iceCandidate' || msg.iceCandidate){
            const cand = msg.iceCandidate || msg;
            try{
                if(peerConnection) await peerConnection.addIceCandidate(new RTCIceCandidate(cand));
                if(broadcasterPC) await broadcasterPC.addIceCandidate(new RTCIceCandidate(cand));
            }catch(e){ console.warn('ice add err', e); }
        }

    }catch(e){
        console.error('ws msg parse err', e);
    }
});

/* render chat lines when user sends or incoming handled above */
function renderChatLine(user, text){
    const p = document.createElement('p');
    p.textContent = user + ': ' + text;
    // append to both viewer and dashboard
    const viewerChat = document.getElementById('chat-container');
    const dashChat = document.getElementById('messages');
    if(viewerChat) viewerChat.appendChild(p.cloneNode(true));
    if(dashChat) dashChat.appendChild(p.cloneNode(true));
}

/* keep old dummy featured example so UI not empty */
(function seedDummy(){
    const f = document.getElementById('featured-streams');
    if(f) {
        if(f.children.length === 0){
            const a = document.createElement('div'); a.className='card'; a.textContent='Stream 1'; f.appendChild(a);
            const b = document.createElement('div'); b.className='card'; b.textContent='Stream 2'; f.appendChild(b);
            const c = document.createElement('div'); c.className='card'; c.textContent='Stream 3'; f.appendChild(c);
        }
    }
})();

</script>
</body>
   </html>
